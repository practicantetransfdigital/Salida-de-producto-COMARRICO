<script>

function cambiarPantalla(idPantalla) {
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });
  document.getElementById(idPantalla).classList.add('active');
  
  // Si cambiamos a la pantalla principal y ya tenemos datos, actualizar la UI
  if (idPantalla === 'mainScreen' && datosCompletos) {
    console.log('üîÑ Actualizando UI con datos existentes...');
    actualizarEstadisticas(datosCompletos.estadisticas || {});
    crearGraficos(datosCompletos.estadisticas || {});
    cargarTabla((datosCompletos.estadisticas && datosCompletos.estadisticas.ultimosRegistros) || []);
  }
}

function mostrarLoading(mostrar) {
  const spinner = document.getElementById('loadingSpinner');
  if (mostrar) {
    spinner.classList.add('active');
  } else {
    spinner.classList.remove('active');
  }
}

function mostrarError(mensaje) {
  const errorDiv = document.getElementById('loginError');
  if (errorDiv) {
    errorDiv.textContent = mensaje;
    errorDiv.style.display = 'block';
  }
}

function limpiarError() {
  const errorDiv = document.getElementById('loginError');
  if (errorDiv) {
    errorDiv.textContent = '';
    errorDiv.style.display = 'none';
  }
}

function formatearFechaSimple(fecha) {
  if (!fecha) return '-';
  
  try {
    // Si ya es una fecha formateada, devolverla tal cual
    if (typeof fecha === 'string' && fecha.match(/\d{2}\/\d{2}\/\d{4}/)) {
      return fecha;
    }
    
    // CORRECCI√ìN: Manejar diferentes formatos de fecha
    let fechaObj;
    if (fecha.includes('T')) {
      // Si viene con timezone, usar directamente
      fechaObj = new Date(fecha);
    } else {
      // Si es solo fecha, agregar tiempo para evitar problemas de zona horaria
      fechaObj = new Date(fecha + 'T00:00:00');
    }
    
    if (isNaN(fechaObj.getTime())) return fecha;
    
    const dia = String(fechaObj.getDate()).padStart(2, '0');
    const mes = String(fechaObj.getMonth() + 1).padStart(2, '0');
    const a√±o = fechaObj.getFullYear();
    
    return `${dia}/${mes}/${a√±o}`;
  } catch (error) {
    return fecha;
  }
}


function errorServidor(error) {
  mostrarLoading(false);
  console.error('‚ùå Error del servidor:', error);
  mostrarNotificacion('Error del servidor: ' + (error.message || 'Error desconocido'), 'error');
}


function obtenerBadgeEstado(estado) {
  const badges = {
    'En Revisi√≥n': 'badge-warning',
    'Devuelto': 'badge-success',
    'Pendiente por Devoluci√≥n': 'badge-error',
    'Procesado': 'badge-info',
    'Destruido': 'badge-error'
  };
  
  return badges[estado] || 'badge-info';
}

function formatearFecha(fecha) {
  if (!fecha) return '-';
  
  // Si ya es una fecha formateada, devolverla tal cual
  if (typeof fecha === 'string' && fecha.match(/\d{2}\/\d{2}\/\d{4}/)) {
    return fecha;
  }
  
  try {
    const d = new Date(fecha);
    if (isNaN(d.getTime())) return fecha;
    
    const dia = String(d.getDate()).padStart(2, '0');
    const mes = String(d.getMonth() + 1).padStart(2, '0');
    const a√±o = d.getFullYear();
    const hora = String(d.getHours()).padStart(2, '0');
    const min = String(d.getMinutes()).padStart(2, '0');
    
    return `${dia}/${mes}/${a√±o} ${hora}:${min}`;
  } catch (error) {
    console.error('Error formateando fecha:', error, fecha);
    return fecha;
  }
}

function obtenerBadgeEstado(estado) {
  const badges = {
    'En Revisi√≥n': 'badge-warning',
    'Devuelto': 'badge-success',
    'Pendiente por Devoluci√≥n': 'badge-info',
    'Procesado': 'badge-info',
    'Destruido': 'badge-error',
    'Vencido': 'badge-error'
  };
  
  return badges[estado] || 'badge-info';
}

function cerrarModalDetalles() {
  document.getElementById('modalDetalles').classList.remove('active');
  registroActual = null;
  pestaniaActual = 'detalles';
}

function calcularTiempoTranscurrido(fecha) {
  if (!fecha) return '-';
  
  try {
    const fechaRegistro = new Date(fecha);
    if (isNaN(fechaRegistro.getTime())) return '-';
    
    const ahora = new Date();
    const diferencia = ahora - fechaRegistro;
    
    const minutos = Math.floor(diferencia / (1000 * 60));
    const horas = Math.floor(minutos / 60);
    const dias = Math.floor(horas / 24);
    
    if (dias > 0) return `${dias} d√≠a${dias > 1 ? 's' : ''}`;
    if (horas > 0) return `${horas} hora${horas > 1 ? 's' : ''}`;
    if (minutos > 0) return `${minutos} minuto${minutos > 1 ? 's' : ''}`;
    return 'Hace unos momentos';
  } catch (error) {
    return '-';
  }
}

function calcularEstadoVencimiento(fechaRetorno, estadoActual) {
  if (!fechaRetorno || estadoActual === 'Devuelto' || estadoActual === 'Destruido' || estadoActual === 'Procesado') {
    return { texto: 'No aplica', clase: 'badge-info' };
  }
  
  try {
    // CORRECCI√ìN: Manejar fecha correctamente
    let fecha;
    if (fechaRetorno.includes('T')) {
      fecha = new Date(fechaRetorno);
    } else {
      fecha = new Date(fechaRetorno + 'T00:00:00');
    }
    
    const hoy = new Date();
    hoy.setHours(0, 0, 0, 0);
    
    const diferencia = fecha - hoy;
    const dias = Math.ceil(diferencia / (1000 * 60 * 60 * 24));
    
    if (dias < 0) {
      return { texto: 'VENCIDO', clase: 'badge-error' };
    } else if (dias === 0) {
      return { texto: 'Vence hoy', clase: 'badge-warning' };
    } else if (dias <= 2) {
      return { texto: `Vence en ${dias} d√≠a${dias > 1 ? 's' : ''}`, clase: 'badge-warning' };
    } else if (dias <= 7) {
      return { texto: `Vence en ${dias} d√≠as`, clase: 'badge-info' };
    } else {
      return { texto: `Vence en ${dias} d√≠as`, clase: 'badge-success' };
    }
  } catch (error) {
    return { texto: 'Error c√°lculo', clase: 'badge-error' };
  }
}

// Funci√≥n para verificar vencimientos autom√°ticamente
function verificarVencimientos() {
  if (!datosCompletos || !datosCompletos.registros) return;
  
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  
  let vencidos = 0;
  let porVencerHoy = 0;
  let porVencerProximos = 0;
  
  datosCompletos.registros.forEach(registro => {
    if (registro.Estado !== 'Devuelto' && registro.Estado !== 'Destruido' && registro.Estado !== 'Procesado') {
      // CORREGIDO: usar "Tiempo Estimado de Retorno"
      const fechaRetorno = new Date(registro['Tiempo Estimado de Retorno']);
      
      if (fechaRetorno < hoy) {
        vencidos++;
      } else if (fechaRetorno.getTime() === hoy.getTime()) {
        porVencerHoy++;
      } else if (fechaRetorno <= new Date(hoy.getTime() + 2 * 24 * 60 * 60 * 1000)) { // Pr√≥ximos 2 d√≠as
        porVencerProximos++;
      }
    }
  });
  
  // Mostrar notificaciones agrupadas en una sola si hay m√∫ltiples alertas
  const alertas = [];
  
  if (vencidos > 0) {
    alertas.push(`‚ö†Ô∏è ${vencidos} salida${vencidos > 1 ? 's' : ''} vencida${vencidos > 1 ? 's' : ''}`);
  }
  
  if (porVencerHoy > 0) {
    alertas.push(`üìÖ ${porVencerHoy} salida${porVencerHoy > 1 ? 's' : ''} vence${porVencerHoy > 1 ? 'n' : ''} hoy`);
  }
  
  if (porVencerProximos > 0) {
    alertas.push(`‚è≥ ${porVencerProximos} salida${porVencerProximos > 1 ? 's' : ''} vence${porVencerProximos > 1 ? 'n' : ''} en 2 d√≠as`);
  }
  
  // Mostrar una sola notificaci√≥n con todas las alertas
  if (alertas.length > 0) {
    const mensaje = `Alertas de vencimiento:\n${alertas.join('\n')}`;
    mostrarNotificacion(mensaje, 'warning');
  }
}

function configurarAutocompletado() {
  const codigoInput = document.getElementById('codigo');
  const nombreInput = document.getElementById('nombreproducto');
  
  codigoInput.addEventListener('input', function() {
    const codigo = this.value.trim().toUpperCase();
    
    if (productosBase[codigo]) {
      // Si el c√≥digo existe, autocompletar nombre
      nombreInput.value = productosBase[codigo];
    } else if (codigo === '') {
      // Si se borra el c√≥digo, limpiar nombre
      nombreInput.value = '';
    }
    // Si no existe, dejar que el usuario escriba manualmente
  });
  
  // Tambi√©n autocompletar al perder el foco (por si acaso)
  codigoInput.addEventListener('blur', function() {
    const codigo = this.value.trim().toUpperCase();
    if (productosBase[codigo] && !nombreInput.value) {
      nombreInput.value = productosBase[codigo];
    }
  });
}

function buscarProducto(codigo) {
  codigo = codigo.trim().toUpperCase();
  
  // B√∫squeda exacta
  if (productosBase[codigo]) {
    return productosBase[codigo];
  }
  
  // B√∫squeda por coincidencia parcial
  for (let key in productosBase) {
    if (key.includes(codigo) || codigo.includes(key)) {
      return productosBase[key];
    }
  }
  
  return null;
}

function llenarSelect(selectId, opciones) {
  const select = document.getElementById(selectId);
  if (!select || !opciones || !Array.isArray(opciones)) {
    console.error(`‚ùå No se pudo llenar select ${selectId}`, opciones);
    return;
  }
  
  // Limpiar opciones existentes (excepto la primera si existe)
  select.innerHTML = '';
  
  opciones.forEach(opcion => {
    const option = document.createElement('option');
    option.value = opcion;
    option.textContent = opcion;
    select.appendChild(option);
  });
}

// Funci√≥n para recargar todo el sistema despu√©s de una edici√≥n
function recargarSistemaCompleto() {
  console.log('üîÑ Recargando sistema completo...');
  
  // Recargar el dashboard si estamos en esa secci√≥n
  if (document.getElementById('seccionDashboard').style.display === 'block' || 
      document.getElementById('seccionDashboard').style.display === '') {
    console.log('üìä Recargando dashboard...');
    cargarDashboard();
  }
  
  // Recargar el historial de vencidos si estamos en esa secci√≥n
  if (document.getElementById('seccionVencidos').style.display === 'block') {
    console.log('üìã Recargando historial vencidos...');
    cargarHistorialVencidos();
  }
  
  // Si estamos viendo detalles de un registro, cerrarlo
  const modalDetalles = document.getElementById('modalDetalles');
  if (modalDetalles && modalDetalles.classList.contains('active')) {
    cerrarModalDetalles();
  }
}

// Funci√≥n para refrescar el apartado de vencidos
function refrescarVencidos() {
  console.log('üîÑ Refrescando datos de vencidos...');
  mostrarLoading(true);
  
  // Agregar animaci√≥n al bot√≥n
  const btn = event.currentTarget;
  const icon = btn.querySelector('i');
  icon.classList.add('fa-spin');
  
  // Recargar primero el dashboard para obtener datos frescos
  google.script.run
    .withSuccessHandler(function(resultado) {
      // Detener animaci√≥n
      icon.classList.remove('fa-spin');
      
      if (resultado && typeof resultado === 'string') {
        try {
          resultado = JSON.parse(resultado);
        } catch (e) {
          console.error('Error parseando respuesta:', e);
        }
      }
      
      if (resultado && resultado.success === true) {
        // Actualizar datos en memoria
        datosCompletos = resultado;
        
        // Recargar la vista de vencidos
        cargarHistorialVencidos();
        
        mostrarNotificacion('‚úÖ Datos de vencidos actualizados', 'success');
        mostrarLoading(false);
      } else {
        mostrarNotificacion('‚ùå Error al actualizar datos', 'error');
        mostrarLoading(false);
      }
    })
    .withFailureHandler(function(error) {
      // Detener animaci√≥n
      icon.classList.remove('fa-spin');
      mostrarNotificacion('‚ùå Error del servidor: ' + error.message, 'error');
    })
    .obtenerDatosDashboard();
}

function forzarRefrescoCompleto() {
  console.log('üîÑ FORZANDO REFRESCO COMPLETO DEL SISTEMA...');
  
  // 1. Limpiar datos actuales
  datosCompletos = null;
  registrosVencidos = [];
  registrosVencidosFiltrados = [];
  
  // 2. Recargar dashboard completo
  mostrarLoading(true);
  
  google.script.run
    .withSuccessHandler(function(resultado) {
      mostrarLoading(false);
      
      if (resultado && typeof resultado === 'string') {
        try {
          resultado = JSON.parse(resultado);
        } catch (e) {
          console.error('Error parseando respuesta:', e);
        }
      }
      
      if (resultado && resultado.success === true) {
        // Actualizar datos en memoria
        datosCompletos = resultado;
        
        // 3. Actualizar vista actual
        if (document.getElementById('seccionDashboard').style.display === 'block' || 
            document.getElementById('seccionDashboard').style.display === '') {
          // Actualizar dashboard
          actualizarEstadisticas(resultado.estadisticas || {});
          crearGraficos(resultado.estadisticas || {});
          cargarTabla((resultado.estadisticas && resultado.estadisticas.ultimosRegistros) || []);
          console.log('‚úÖ Dashboard actualizado');
        }
        
        if (document.getElementById('seccionVencidos').style.display === 'block') {
          // Actualizar historial vencidos
          cargarHistorialVencidos();
          console.log('‚úÖ Historial vencidos actualizado');
        }
        
        // 4. Actualizar contador de vencidos en navbar
        actualizarContadorVencidosEnDashboard();
        
        mostrarNotificacion('‚úÖ Sistema actualizado completamente', 'success');
        
      } else {
        mostrarNotificacion('‚ùå Error al recargar datos', 'error');
      }
    })
    .withFailureHandler(function(error) {
      mostrarLoading(false);
      mostrarNotificacion('‚ùå Error al recargar datos del servidor', 'error');
    })
    .obtenerDatosDashboard();
}

function generarColorPorIndice(index) {
  const colores = [
    '#FF6B6B', '#4ECDC4', '#FFD166', '#06D6A0', '#118AB2',
    '#EF476F', '#FFD166', '#06D6A0', '#118AB2', '#073B4C'
  ];
  return colores[index % colores.length];
}

function generarColoresCalidos(cantidad) {
  const coloresBase = [
    '#FDB913', '#F59E0B', '#FBBF24', '#FCD34D', '#FDE047',
    '#FEF08A', '#FFE5B4', '#FFDAB9', '#FFA500', '#FF8C00'
  ];
  
  if (cantidad <= coloresBase.length) {
    return coloresBase.slice(0, cantidad);
  }
  
  const colores = [];
  for (let i = 0; i < cantidad; i++) {
    const hue = 40 + (i * 20);
    colores.push(`hsl(${hue}, 90%, 60%)`);
  }
  return colores;
}

</script>