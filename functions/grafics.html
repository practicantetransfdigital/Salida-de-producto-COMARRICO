<script>

function crearGraficos(stats) {
  if (!stats) {
    console.warn('‚ö†Ô∏è No hay estad√≠sticas para crear gr√°ficos');
    return;
  }
  
  console.log('üé® Creando gr√°ficos con estad√≠sticas:', stats);
  
  // 1. Normalizar estad√≠sticas (ubicaciones a may√∫sculas)
  const statsNormalizados = normalizarEstadisticas(stats);
  
  // 2. Destruir gr√°ficos anteriores
  Object.values(charts).forEach(chart => {
    if (chart && typeof chart.destroy === 'function') {
      chart.destroy();
    }
  });
  charts = {};
  
  const commonOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'bottom',
        labels: {
          font: {
            family: '-apple-system, BlinkMacSystemFont, sans-serif',
            size: 12
          },
          padding: 15
        }
      }
    }
  };
  
  const coloresCalidos = [
    '#FDB913', '#F59E0B', '#FBBF24', '#FCD34D', 
    '#FDE047', '#FEF08A', '#FFE5B4', '#FFDAB9'
  ];
  
  // 3. Crear gr√°ficos individuales
  crearGraficoIndividual('chartTipoSalida', 'doughnut', statsNormalizados.porTipoSalida, coloresCalidos, commonOptions);
 crearGraficaPlagasConCantidadSimple(statsNormalizados);
  
  crearGraficoIndividual('chartPasillo', 'bar', statsNormalizados.porPasillo, ['#F59E0B'], {
    ...commonOptions,
    indexAxis: 'y',
    scales: { x: { beginAtZero: true, ticks: { stepSize: 1 } } }
  });
  
  crearGraficoIndividual('chartEstado', 'pie', stats.porEstado, coloresCalidos, commonOptions);
  
  // 4. Crear gr√°fica de plagas por ubicaci√≥n (estad√≠stica cruzada)
  if (datosCompletos && datosCompletos.registros) {
    console.log('üìä Creando gr√°fica de plagas por ubicaci√≥n con', datosCompletos.registros.length, 'registros');
    crearGraficaPlagasPorUbicacion(datosCompletos.registros);
  } else {
    console.warn('‚ö†Ô∏è No hay datos completos para gr√°fica de plagas por ubicaci√≥n');
  }
}

function crearGraficoIndividual(canvasId, tipo, datos, colores, opciones) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) {
    console.error(`‚ùå No se encontr√≥ el canvas: ${canvasId}`);
    return;
  }
  
  const parent = canvas.parentElement;
  
  const canvasExistente = document.getElementById(canvasId);
  if (canvasExistente) {
    canvasExistente.remove();
  }
  
  const mensajesAnteriores = parent.querySelectorAll('.no-data-message, .error-message');
  mensajesAnteriores.forEach(msg => msg.remove());

  if (charts[canvasId]) {
    charts[canvasId].destroy();
  }

  const nuevoCanvas = document.createElement('canvas');
  nuevoCanvas.id = canvasId;
  
  nuevoCanvas.style.width = '100%';
  nuevoCanvas.style.height = '300px';
  nuevoCanvas.style.minHeight = '300px';
  nuevoCanvas.style.maxHeight = '300px';
  
  parent.appendChild(nuevoCanvas);
  
  if (!datos || Object.keys(datos).length === 0) {
    const mensajeDiv = document.createElement('div');
    mensajeDiv.className = 'no-data-message';
    mensajeDiv.innerHTML = '<p>No hay datos disponibles</p>';
    mensajeDiv.style.height = '300px';
    mensajeDiv.style.display = 'flex';
    mensajeDiv.style.alignItems = 'center';
    mensajeDiv.style.justifyContent = 'center';
    parent.appendChild(mensajeDiv);
    return;
  }
  
  const datosFiltrados = {};
  Object.keys(datos).forEach(key => {
    if (datos[key] > 0) {
      datosFiltrados[key] = datos[key];
    }
    console.log(`üîç Etiquetas para ${canvasId}:`, Object.keys(datos));
  });
  
  if (Object.keys(datosFiltrados).length === 0) {
    const mensajeDiv = document.createElement('div');
    mensajeDiv.className = 'no-data-message';
    mensajeDiv.innerHTML = '<p>No hay datos disponibles</p>';
    mensajeDiv.style.height = '300px';
    mensajeDiv.style.display = 'flex';
    mensajeDiv.style.alignItems = 'center';
    mensajeDiv.style.justifyContent = 'center';
    parent.appendChild(mensajeDiv);
    return;
  }
  
  const ctx = nuevoCanvas.getContext('2d');
  
  try {
    charts[canvasId] = new Chart(ctx, {
      type: tipo,
      data: {
        labels: Object.keys(datosFiltrados),
datasets: [{
  label: obtenerLabelGrafico(canvasId, tipo),
  data: Object.values(datosFiltrados),
  backgroundColor: colores,
  borderWidth: 2,
  borderColor: '#fff',
  borderRadius: tipo === 'bar' ? 8 : 0
}]
      },
      options: {
        ...opciones,
        responsive: true,
        maintainAspectRatio: false
      }
    });
  } catch (error) {
    console.error(`‚ùå Error creando gr√°fico ${canvasId}:`, error);
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.innerHTML = '<p>Error al crear gr√°fico</p>';
    errorDiv.style.height = '300px';
    errorDiv.style.display = 'flex';
    errorDiv.style.alignItems = 'center';
    errorDiv.style.justifyContent = 'center';
    parent.appendChild(errorDiv);
  }
}

// Funci√≥n para obtener la leyenda correcta de cada gr√°fico
function obtenerLabelGrafico(canvasId, tipo) {
  const labels = {
    'chartTipoSalida': 'Tipos de Salida',
    'chartTipoPlaga': 'Cantidad',  
    'chartPasillo': 'Cantidad',    
    'chartEstado': 'Estados'
  };
  
  // Si no est√° en la lista, usar valor por defecto
  return labels[canvasId] || (tipo === 'bar' ? 'Cantidad' : '');
}

function actualizarEstadisticas(stats) {
  if (!stats) {
    console.warn('‚ö†Ô∏è Stats es null o undefined');
    stats = {
      totalSalidas: 0,
      porEstado: {}
    };
  }
  
  document.getElementById('totalSalidas').textContent = stats.totalSalidas || 0;
  document.getElementById('enRevision').textContent = (stats.porEstado && stats.porEstado['En Revisi√≥n']) || 0;
  document.getElementById('devueltos').textContent = (stats.porEstado && stats.porEstado['Devuelto']) || 0;
  document.getElementById('pendientes').textContent = (stats.porEstado && stats.porEstado['Pendiente por Devoluci√≥n']) || 0;
}

function crearGraficoCruzado(canvasId, tipo, data, totales = null) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) {
    console.error(`‚ùå No se encontr√≥ el canvas: ${canvasId}`);
    return;
  }
  
  const parent = canvas.parentElement;
  
  // Limpiar canvas anterior
  const canvasExistente = document.getElementById(canvasId);
  if (canvasExistente) {
    canvasExistente.remove();
  }
  
  // Limpiar mensajes
  const mensajesAnteriores = parent.querySelectorAll('.no-data-message, .error-message');
  mensajesAnteriores.forEach(msg => msg.remove());
  
  // Destruir gr√°fico anterior
  if (charts[canvasId]) {
    charts[canvasId].destroy();
  }
  
  // Crear nuevo canvas
  const nuevoCanvas = document.createElement('canvas');
  nuevoCanvas.id = canvasId;
  nuevoCanvas.style.cssText = `
    width: 100%;
    height: 300px;
    min-height: 300px;
    max-height: 300px;
  `;
  parent.appendChild(nuevoCanvas);
  
  const ctx = nuevoCanvas.getContext('2d');
  
  try {
    // üéØ PREPARAR ETIQUETAS CON TOTALES SI EST√ÅN DISPONIBLES
    let labelsFinales = data.labels;
    if (totales && totales.length === data.labels.length) {
      labelsFinales = data.labels.map((label, index) => {
        const total = totales[index];
        return `${label} (${total})`;
      });
    }
    
    charts[canvasId] = new Chart(ctx, {
      type: tipo,
      data: {
        labels: labelsFinales,
        datasets: data.datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              font: {
                family: '-apple-system, BlinkMacSystemFont, sans-serif',
                size: 11
              },
              padding: 15,
              boxWidth: 12,
              boxHeight: 12
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                let label = context.dataset.label || '';
                if (label) {
                  label += ': ';
                }
                label += context.parsed.y;
                return label;
              },
              // üéØ AGREGAR TOTAL AL FOOTER DEL TOOLTIP
              footer: function(tooltipItems) {
                if (totales && tooltipItems.length > 0) {
                  const dataIndex = tooltipItems[0].dataIndex;
                  const totalUbicacion = totales[dataIndex];
                  const ubicacionOriginal = data.labels[dataIndex];
                  return `Total en ${ubicacionOriginal}: ${totalUbicacion}`;
                }
                return '';
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              stepSize: 1,
              font: { size: 11 }
            },
            title: {
              display: true,
              text: 'Cantidad de Plagas',
              font: { size: 12, weight: 'bold' }
            }
          },
          x: {
            ticks: {
              font: { size: 10 },
              maxRotation: 45,
              minRotation: 45,
              autoSkip: false,
              callback: function(value, index) {
                const label = this.chart.data.labels[index];
                if (!label) return '';
                
                // Truncar si es muy largo pero mantener el total
                const maxChars = 20;
                if (label.length > maxChars) {
                  // Intentar extraer nombre y cantidad si tiene formato "Nombre (X)"
                  const match = label.match(/^([^(]+)\((\d+)\)$/);
                  if (match) {
                    const nombre = match[1].trim();
                    const cantidad = match[2];
                    const nombreCorto = nombre.length > (maxChars - 6) 
                      ? nombre.substring(0, maxChars - 8) + '...'
                      : nombre;
                    return `${nombreCorto} (${cantidad})`;
                  }
                  // Si no tiene formato, truncar normalmente
                  return label.substring(0, maxChars - 3) + '...';
                }
                return label;
              }
            },
            title: {
              display: true,
              text: 'Ubicaciones (Total)',
              font: { size: 12, weight: 'bold' }
            }
          }
        },
        layout: {
          padding: {
            left: 10,
            right: 10,
            top: 10,
            bottom: 30
          }
        }
      }
    });
    
    console.log(`‚úÖ Gr√°fico ${canvasId} creado con totales:`, totales);
    
  } catch (error) {
    console.error(`‚ùå Error creando gr√°fico ${canvasId}:`, error);
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.innerHTML = `
      <p>Error al crear gr√°fico</p>
      <small>${error.message}</small>
    `;
    errorDiv.style.cssText = `
      height: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: #fff0f0;
      border-radius: 8px;
      border: 1px solid #ffcccc;
      padding: 20px;
    `;
    parent.appendChild(errorDiv);
  }
}

function crearGraficaPlagasConCantidadSimple(stats) {
  if (!stats || !stats.porTipoPlaga) {
    console.warn('‚ö†Ô∏è No hay estad√≠sticas de plagas');
    return;
  }
  
  // Ordenar plagas por cantidad (descendente)
  const plagasOrdenadas = Object.entries(stats.porTipoPlaga)
    .filter(([plaga, cantidad]) => cantidad > 0)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10); // Top 10
  
  if (plagasOrdenadas.length === 0) {
    console.log('‚ÑπÔ∏è No hay datos de plagas');
    return;
  }
  
  // Preparar datos con cantidades en etiquetas
  const labels = plagasOrdenadas.map(([plaga, cantidad]) => `${plaga} (${cantidad})`);
  const data = plagasOrdenadas.map(([plaga, cantidad]) => cantidad);
  
  // Crear o actualizar gr√°fico
  const canvas = document.getElementById('chartTipoPlaga');
  if (!canvas) return;
  
  const parent = canvas.parentElement;
  
  // Limpiar canvas anterior
  const canvasExistente = document.getElementById('chartTipoPlaga');
  if (canvasExistente) {
    canvasExistente.remove();
  }
  
  // Limpiar mensajes
  const mensajesAnteriores = parent.querySelectorAll('.no-data-message, .error-message');
  mensajesAnteriores.forEach(msg => msg.remove());
  
  // Destruir gr√°fico anterior
  if (charts['chartTipoPlaga']) {
    charts['chartTipoPlaga'].destroy();
  }
  
  // Crear nuevo canvas
  const nuevoCanvas = document.createElement('canvas');
  nuevoCanvas.id = 'chartTipoPlaga';
  nuevoCanvas.style.cssText = `
    width: 100%;
    height: 300px;
    min-height: 300px;
    max-height: 300px;
  `;
  parent.appendChild(nuevoCanvas);
  
  const ctx = nuevoCanvas.getContext('2d');
  
  try {
    charts['chartTipoPlaga'] = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Cantidad',
          data: data,
          backgroundColor: '#FDB913',
          borderWidth: 2,
          borderColor: '#fff',
          borderRadius: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                // Mostrar solo el nombre en el tooltip
                const fullLabel = context.label || '';
                const match = fullLabel.match(/^([^(]+)/);
                const plagaNombre = match ? match[1].trim() : fullLabel;
                return `${plagaNombre}: ${context.raw}`;
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              stepSize: 1,
              font: { size: 11 }
            },
            title: {
              display: true,
              text: 'Cantidad',
              font: { size: 12, weight: 'bold' }
            }
          },
          x: {
            ticks: {
              font: { size: 10 },
              maxRotation: 45,
              minRotation: 45,
              autoSkip: false,
              callback: function(value, index) {
                const label = this.chart.data.labels[index];
                if (!label) return '';
                
                // Truncar si es muy largo
                const maxChars = 15;
                if (label.length > maxChars) {
                  const match = label.match(/^([^(]+)\((\d+)\)$/);
                  if (match) {
                    const nombre = match[1].trim();
                    const cantidad = match[2];
                    const nombreCorto = nombre.substring(0, maxChars - 6) + '...';
                    return `${nombreCorto} (${cantidad})`;
                  }
                }
                return label;
              }
            },
            title: {
              display: true,
              text: 'Tipo de Plaga (Cantidad)',
              font: { size: 12, weight: 'bold' }
            }
          }
        },
        layout: {
          padding: {
            left: 10,
            right: 10,
            top: 10,
            bottom: 30
          }
        }
      }
    });
    
    console.log('‚úÖ Gr√°fica de plagas creada con cantidades:', plagasOrdenadas);
    
  } catch (error) {
    console.error('‚ùå Error creando gr√°fica de plagas:', error);
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.innerHTML = '<p>Error al crear gr√°fico de plagas</p>';
    errorDiv.style.cssText = `
      height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff0f0;
      border-radius: 8px;
      border: 1px solid #ffcccc;
    `;
    parent.appendChild(errorDiv);
  }
}

</script>